第七章 面向对象编程(中级部分)
一.IntelliJ IDEA(集成开发环境)
1.IDEA介绍
(1).IDEA 全称IntelliJ IDEA. 
(2).在业界被公认为最好的Java开发工具. 
(3).IDEA是JetBrains公司的产品，总部位于捷克的首都布拉格. 
(4).除了支持Java开发，还支持.
2.Eclipse介绍
(1).Eclipse是一个开放源代码的、基于Java的可扩展开发平台. 
(2).最初是由IBM公司耗资3000万美金开发的下一代IDE 开发环境. 
(3).2001年11月贡献给开源社区. 
(4).Eclipse是目前最优秀的Java开发IDE之一.
3.IDEA的使用技巧和经验
(1).设置代码字体大小:IntelliJ IDEA-->Settings-->Editor-->Font-->Size.
(2).设置菜单导航字体大小:IntelliJ IDEA-->Settings-->Appearance-->选中☑️
    -->Size.
(3).设置代码字体粗细:IntelliJ IDEA-->Settings-->Color Scheme-->General
    -->Text-->default text-->Bold-->apply-->ok.(变粗)
(4).设置主题:IntelliJ IDEA-->Settings-->Color Scheme-->Scheme.
(5).字符编码设置:IntelliJ IDEA-->Settings-->Editor-->Code Style-->File Encodings
    -->Global Encoding(全局编码)/Project Encoding(项目编码).
(6).在idea 当我们run一个文件时，会编译成.class->再运行.
    src存放源码文件，out存放编译后的.class文件.
4.IDEA常用快捷键
(1).删除当前行,默认是command+delete. 自己配置ctrl + d 
(2).复制当前行,自己配置command+D. 
(3).补全代码option+/. 
(4).添加注释和取消注释ctrl+/. 【第一次是添加注释，第二次是取消注释】 
(5).导入该行需要的类先配置auto import,然后使用option+return，再点return即可.
(6).快速格式化代码option+command+L. 
(7).快速运行程序定义control+R. 
(8).生成构造器等command+N,再return,选构造器里的形参. [提高开发效率] 
(9).查看一个类的层级关系control+H [学习继承后，非常有用] 
(10).将光标放在一个方法上,输入command+B,可以定位到方法 [学继承后，非常有用] 
(11).自动的分配变量名,通过在后面➕.var [老师最喜欢的] 
(12).还有很多其它的快捷键...
5.模板/自定义模板
file->settings->editor->Code Style->Live templates->
查看有哪些模板快捷键/可以自己增加模板.
模板可以高效的完成开发，提高速度.
(1). //main就是一个模板的快捷键，
     public static void main(String[] args) {
     }
(2). //sout模版快捷键
     System.out.println("hello,world");
(3). //fori模板快捷键
     for (int i = 0; i < ; i++) {
     }
二.包
1.包的三大作用
(1).区分相同名字的类.
(2).当类很多时，可以很好的管理类.[看Java API文档]
(3).控制访问范围.
2.包基本语法
package com.hspedu;
说明:
(1).package关键字，表示打包.
(2).com.hspedu:表示包名.
3.包的本质
实际上就是创建不同的文件夹/目录来保存类文件.
src->new->Package->com.文件名.
4.包的命名
(1).命名规则:
只能包含数字、字母、下划线、小圆点.但不能用数字开头，不能是关键字或保留字.
demo.class.exec1//❌，有关键字class
demo.12a//❌，数字开头
demo.ab12.oa//✅
(2).命名规范
-般是小写字母+小圆点一般是:com.公司名项目名业务模块名
比如: com.hspedu.oa.model; com.hspedu.oa.controller;
举例:
com.sina.crm.user //用户模块
com.sina.crm.order /订单模块
com.sina.crm.utils //工具类
5.常用的包
一个包下,包含很多的类,java 中常用的包有:
(1).java.lang.*//lang包是基本包，默认引入，不需要再引入.
(2).java.util.*//util 包，系统提供的工具包，工具类，使用Scanner. 
(3).java.net.*//网络包，网络开发. 
(4).java.awt.*//是做java的界面开发，GUI.
6.如何引入包
com.hspedu.pkg:Import01.java
语法:import包;
我们引入一个包的主要目的是要使用该包下的类.
比如import java.util.Scanner;就只是引入一个类Scanner.
import java.util.*; //表示将java.util包所有都引入.
建议需要哪个类就导入哪个类即可，不建议使用*导入.
import java.util.Arrays;
Arrays.sort(arr);//使用系统提供的方法完成排序
7.注意事项和使用细节
(1).package的作用是声明当前类所在的包，需要放在class类的最上面，一个类中最多只有一句package.
(2).import指令位置放在package的下面，在类定义前面，可以有多句且没有顺序要求.
三.访问修饰符
1.基本介绍
java 提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限(范围): 
(1).公开级别:用public修饰,对外公开. 
(2).受保护级别:用protected修饰,对子类和同一个包中的类公开. 
(3).默认级别:没有修饰符号,向同一个包的类公开. 
(4).私有级别:用private修饰,只有类本身可以访问,不对外公开.
2.四种访问修饰符的访问范围
序号    访问级别    访问控制修饰符     同类    同包    子类    不同包
(1)       公开         public      ✅     ✅      ✅       ✅
(2)       受保护       protecte    ✅     ✅      ✅       ❌
(3)       默认         没有修饰符   ✅     ✅      ❌       ❌ 
(4)       私有         private    ✅     ❌      ❌       ❌
3.使用的注意事项
(1).修饰符可以用来修饰类中的属性，成员方法以及类.
(2).只有默认的和public才能修饰类，并且遵循上述访问权限的特点.
(3).因为没有学习继承，因此关于在子类中的访问权限，要等听完子类后才懂.
(4).成员方法的访问规则和属性完全一样.
//com.hspedu.modifier :需要很多文件来说明(A类，B类,Test.类..)
四.封装
1.基本介绍
封装(encapsulation)就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其它部分只能通过被授权的操作[方法]，才能对数据进行操作.
对电视的操作就是典型封装.
2.封装的理解和好处
(1).隐藏实现细节  方法(连接数据库)<--调用(传入参数--)
(2).可以对数据进行验证，保证安全合理.
    Person(name,age)
3.封装的实现步骤
(1).将属性进行私有化private (不能直接修改属性).
(2).提供一个公共的(public)set方法，用于对属性判断并赋值.
    public void setXxx(类型参数名){//Xxx表示某个属性
    //加入数据验证的业务逻辑
    属性=参数名;
    }
(3).提供一个公共的(public)get方法，用于获取属性的值.
    public数据类型getXxx(){ //权限判断,Xxx某个属性
    return xX;
    }
五.继承
1.基本介绍
继承可以解决代码复用,让我们的编程更加靠近人类思维.当多个类存在相同的属性(变量)和方法时,可以从这些类中抽象出父类,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类即可。画出继承的示意图.
                       继承的示意图
                      
                        A类[父类，基类,超类]
             extends    共有属性<----------
            --------- > 共有方法           ｜extends
           |                               ｜
           B类[A的子类，派生类]              C类[A的子类，派生类]
       --> 特有属性                       特有属性<--
      |    特有方法                       特有方法   |extends
      |extends                                       |
      D类[子类，派生类]                       E类[子类，派生类]
      特有属性                                特有属性    
      特有方法                                特有方法 

    
2.继承的基本语法
class 子类 extends 父类{
}
(1).子类就会自动拥有父类定义的属性和方法.
(2).父类又叫超类，基类.
(3).子类又叫派生类.
3.继承给编程带来的便利
(1).代码的复用性提高了.
(2).代码的扩展性和维护性提高了.
4.继承的细节问题
(1).子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访问，要通过父类提供公共的方法去访问. 
(2).子类必须调用父类的构造器， 完成父类的初始化.
(3).当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过.
(4).如果希望指定去调用父类的某个构造器，则显式的调用一下:super(参数列表). 
(5).super在使用时，必须放在构造器第一行(super 只能在构造器中使用). 
(6).super()和this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器.
(7).java 所有类都是Object类的子类, Object 是所有类的基类. 
(8).父类构造器的调用不限于直接父类！将一直往上追溯直到Object类(顶级父类). 
(9).子类最多只能继承一个父类(指直接继承)，即java中是单继承机制.思考:如何让A类继承B类和C类？ 【A继承B，B继承C】 
(10).不能滥用继承，子类和父类之间必须满足is-a的逻辑关系.
     Person is a Music?
     Person Music
     Music extends Person 不合理
    
     Animal
     Cat extents Animal//合理
5.继承的本质
这时请大家注意，要按照查找关系来返回信息
(1) 首先看子类是否有该属性
(2) 如果子类有这个属性，并且可以访问，则返回信息 
(3) 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..) 
(4) 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object...
六.Super关键字
1.基本介绍
super代表父类的引用，用于访问父类的属性、方法、构造器.
2.基本语法
(1).访问父类的属性,但不能访问父类的private属性.
    super.属性名;
(2).访问父类的方法，不能访问父类的private方法.
    super.方法名(参数列表);
(3).访问父类的构造器(这点前面用过):
    super(参数列表);只能放在构造器的第一句，只能出现一句.
3.super的便利
//SuperDetail.java
1.调用父类的构造器的好处(分工明确，父类属性由父类初始化，子类的属性由子类初始化).
2.当子类中有和父类中的成员(属性和方法)重名时，为了访问父类的成员，必须通过super。
  如果没有重名，使用super、this、 直接访问是一样的效果! 
3.super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员:
如果多个基类(上级类)中都有同名的成员，使用super访问遵循就近原则。A->B->C，当然也需要遵守访问权限的相关规则.
4.super和this的比较
No.     区别点             this                          super
1       访问属性          访问本类中的属性，如果本       访问父类中的属性
                          类没有此属性则从父类中继
                          续查找
2       调用方法          访问本类中的方法，如果本       直接访问父类中的方法
                          类没有此方法则从父类继续
                          查找
3       调用构造器        调用本类构造器，必须放在       调用父类构造器，必须放在子
                          构造器的首行                   类构造器的首行
4       特殊              表示当前对象                   子类中访问父类对象
七.方法重写/覆盖(overwrite)
1.基本介绍
简单的说:方法覆盖(重写)就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的那个方法.
2.注意事项和使用细节[看Animal和Dog]
方法重写也叫方法覆盖，满足下面的条件://OverrideDetail.java
1. 子类的方法的形参列表，方法名称,要和父类方法的形参列表，方法名称完全一样。 
2.子类方法的返回类型和父类方法返回类型一样， 或者是父类返回类型的子类
  比如父类返回类型是object 子类方法返回类型是String 
  public object getInfo(){
  public String getInfo(){
3.子类方法不能缩小父类方法的访问权限 public > protected >默认> private
  父类void say0k(){
  子类public Void say0k(){
4.请对方法的重写和重载做一个比较
请对方法的重写和重载做一个比较: 2min
名称          发生范围      方法名     形参列表             返回类型         修饰符
重载(overload)  本类        必须一样   类型，个数或者顺       无要求          无要求
                                    序至少有一个不同
重写(override) 父子类       必须一     相同                子类重写的方法， 子类方法不
                                                        返回的类型和父   能缩小父类
                                                        类返回的类型一   方法的访问
                                                        致，或者是其子类 范围
八.多态
1.编写主人给动物喂食物的信息.com.hspedu.poly_:Poly01.java
  传统的方法带来的问题是什么? 如何解决? 
  问题是: 代码的复用性不高，而且不利于代码维护. 
  解决方案:使用多态.
2.多态的基本介绍
  方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的.
3.多态的具体表现
(1).方法的多态 PloyMethod.java (重载/重写）
(2).对象的多态（编译类型和运行类型可以不一致，编译类型在定义时就确定，不能变化；运行类型可以变化，通过getClass()查看运行类型）
记住:
(1).一个对象的编译类型和运行类型可以不一致.
(2).编译类型在定义对象时，就确定了，不能改变.
(3).运行类型是可以变化的.
(4).编译类型看定义时=的左边，运行类型看=的右边.
    Animal animal = new Dog();[animal编译类型是Animal,运行类型Dog]
    animal = new Cat(); [animal的运行类型变成了Cat,编译类型仍然是Animal]
案例:com.hspedu.poly_.objpoly_:PolyObject.java
4.多态注意事项和使用细节
com.hspedu.poly_.detail_ 包 : PolyDetail.java 
多态的前提是：两个对象(类)存在继承关系.
多态的向上转型
(1).本质:父类的引用指向了子类的对象.
(2).语法:父类类型 引用名= new 子类类型();
    比如:Animal animal = new Dog();
(3).特点:编译类型看左边，运行类型看右边。
    可以调用父类中的所有成员(需遵守访问权限)，
    不能调用子类中特有成员;最终运行效果看子类的具体实现!
    因为在编译阶段，能调用哪些成员,是由编译类型来决定的.
    最终运行效果看子类(运行类型)的具体实现, 即调用方法时，
    按照从子类(运行类型)开始查找方法 ，然后调用.
多态向下转型
(1).语法:子类类型 引用名= (子类类型)父类引用;
(2).只能强转父类的引用，不能强转父类的对象.
(3).要求父类的引用必须指向的是当前目标类型的对象.
(4).当向下转型后，可以调用子类类型中所有的成员.
    属性没有重写之说！属性的值看编译类型 PolyDetail02.java
    instanceOf 比较操作符，用于判断对象的运行类型是否为 XX 类型或 XX 类型的子类型
    PolyDetail03.java
练习题
public class PolyExercise01 {
    public static void main(String[] args) {
        //请说出下面的每条语言，哪些是正确的，哪些是错误的.
        double d = 13.4;//✅
        long l = (long) d;//✅
        System.out.println(l);//✅
        int in = 5;//✅
        boolean b = (boolean)in;//❌
        Object obj = "Hello";//✅,向上转型
        String objStr = (String) obj;//✅,向下转型
        System.out.println(objStr);//✅ hello
        Object objPri = new Integer(5);//✅
        String str = (String)objPri;//❌，指向Integer的父类引用，转成String.
        Integer str1 = (integer)objPri;//✅，向下转型
    }
}
4.java的动态绑定机制(非常非常重要)
(1).当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定.
(2).当调用对象属性时，没有动态绑定机制,哪里声明，那里使用.
5.多态的应用
(1).多态数组 com.hspedu.poly_.polyarr_ 包PloyArray.java
数组的定义类型为父类类型，里面保存的实际元素类型为子类类型 
应用实例:现有一个继承结构如下：要求创建1个Person对象、2个Student对象和2个Teacher对象, 统一放在数组中，并调用每个对象的say方法。
(2).多态参数
方法定义的形参类型为父类类型，实参类型允许为子类类型.
com.hspedu.poly_.polyparameter_ 包 PloyParameter.java
定义员工类Employee,包含姓名和月工资[private],以及计算年工资getAnnual的方法。普通员工和经理继承了员工，经理类多了奖金bonus属性和管理manage方法，普通员工多了work方法，普通员工和经理类要求重写getAnnual方法.
测试类中添加一个方法showEmpAnnal(Employee e),实现获取任何员工对象的年工资，并在main方法中调用该方法[e.getAnnual()].
测试类中添加一个方法，testWork，如果是普通员工，则调用work方法，如果是经理，则调用manage方法.
九.Object类详解
1.equals方法
==和equals的对比：
com.hspedu.Object_:Equals01.java
==是一个比较运算符.
(1). ==:既可以判断基本类型，又可以判断引用类型。
(2). ==:如果判断基本类型，判断的值是否相等。示例:int i = 10;double d = 10.0;
(3). ==:如果判断引用类型，判断的是地址是否相等，即判定是不是同一个对象。
(4). equals:是Object类中的方法，只能判断引用类型。
(5). 默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。比如:Integer,String(看看String和Integer的equals源代码）
2.hashCode方法
(1).提高具有哈希结构的容器的效率！ 
(2).两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！ 
(3).两个引用，如果指向的是不同对象，则哈希值是不一样的. 
(4).哈希值主要根据地址号来的！不能完全将哈希值等价于地址。
(5).案例演示[HashCode_.java]: obj.hashCode() [测试：A obj1 = new A(); A obj2 = new A(); A obj3 = obj1] (6).后面在集合，中hashCode如果需要的话，也会重写, 在讲解集合时，老韩在说如何重写hashCode()代码
3.toString方法
(1).基本介绍
    默认返回：全类名+@+哈希值的十六进制，【查看 Object 的 toString 方法】
    子类往往重写 toString 方法，用于返回对象的属性信息
(2).重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式.
    案例演示：Monster [name, job, sal] 案例: ToString_.java 
(3).当直接输出一个对象时，toString 方法会被默认的调用.
    比如 System.out.println(monster)； 就会默认调用monster.toString()
4.finalize方法
(1).当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作【演示】
(2).什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用 finalize 方法。 
(3).垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 System.gc() 主动触发垃圾回收机制，测试：Car [name]
十.断点调试(debug)
1.实际需求
(1).在开发过程中，新手程序在查找错误时，可以用断点调试，一步一步的看源码执行的过程，从而发现错误所在.
(2).重要提示:在断点调试过程中，是运行状态，是以对象的运行类型来执行的.
A extends B; B b = new A();b.xx();
2.基本介绍
(1).断点调试是指在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，
    调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个Bug.
(2).断点调试是程序员必须掌握的技能.
(3).断点调试也能帮助我们查看java底层源代码的执行过程，提高程序员的Java水平.
3.断点调试的快捷键
F7(跳入) F8(跳过) shift+F8(跳出) F9(resume,执行到下一个断点)
F7:跳入方法内
F8:逐行执行代码
shift+F8:跳出方法
4.断点调试应用案例
案例 1 com.hspedu.debug_ 包 Debug01.java
看一下变量的变化情况等 F8:逐行执行代码
案例 2 看一下数组越界的异常 Debug02.java F8:逐行执行代码
案例 3 演示如何追源码，看看 java 设计者是怎么实现的。(提高编程思想)。 F7:跳入方法内
小技巧：将光标放在某个变量上，可以看到最新的数据。 Debug03.java
案例 4 演示如何直接执行到下一个断点 F9 resume。 小技巧: 断点可以在 debug 过程中，动态的下断点 Debug04.java
